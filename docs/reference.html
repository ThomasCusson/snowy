
<!DOCTYPE html>

<head>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-19914519-2">
</script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-19914519-2');
</script>
<title>Snowy</title>
<link href="snowflake64.png" rel="icon" type="image/x-icon"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<meta charset="utf-8"/>
<meta content="https://prideout.net/snowy/snowy2.png" property="og:image"/>
<meta content="GitHub" property="og:site_name"/>
<meta content="object" property="og:type"/>
<meta content="prideout/snowy" property="og:title"/>
<meta content="https://prideout.net/snowy/" property="og:url"/>
<meta content="Small Python 3 module for manipulating and generating images." property="og:description"/>
<link href="https://fonts.googleapis.com/css?family=Alegreya" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet"/>
<style>
body {
    margin: 0;
    font-size: 15px;
    font-family: "Avenir Next", "HelveticaNeue", "Helvetica Neue",
        Helvetica, Arial, "Lucida Grande", sans-serif;
    text-rendering: optimizeLegibility;
    font-weight: 400;
    -webkit-font-smoothing:auto;
    background-color: #e2e2e2;
}
a {
    text-decoration: none;
    color: #2962ad;
}
hr {
     border: 0;
    border-bottom: 1px dashed #ccc;
    background: #999;
}
small, small a {
    color: #a0a0a0;
    margin-top: 26px;
}
td:first-child {
    padding-right: 15px;
}
p:first-child {
    clear: left;
}
h1 {
    margin-top: 0;
    margin-bottom: 0;
    font-family: 'Alegreya', serif;
    font-size: 45px;
}
main {
    overflow: auto;
    margin: 0 auto;
    padding: 0 80px 20px 80px;
    max-width: 800px;
    background-color: #ffffff;
    position: relative;
    color: #404040;
    border-left: solid 2px black;
    border-right: solid 2px black;
}
@media (max-width: 960px){
    body{ background-color: #f2f2f2; }
    main{ padding: 0 20px 100px 20px; }
}
img {
    max-width: 100%;
}
pre {
    padding: 10px;
    background-color: #f8f8f8;
    white-space: pre-wrap;
    font-family: 'Inconsolata', monospace;
}
code {
    font-family: 'Inconsolata', monospace;
}
p.aside {
    background: white;
    font-size: small;
    border: solid 1px gray;
    border-left: solid 5px gray;
    padding: 10px;
}
h2 a, h3 a, h4 a { color: black }
h2 a:hover, h3 a:hover, h4 a:hover { color: #19529d }
</style>
<style>.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #8f5902; font-style: italic } /* Comment */
.highlight .err { color: #a40000; border: 1px solid #ef2929 } /* Error */
.highlight .g { color: #000000 } /* Generic */
.highlight .k { color: #204a87; font-weight: bold } /* Keyword */
.highlight .l { color: #000000 } /* Literal */
.highlight .n { color: #000000 } /* Name */
.highlight .o { color: #ce5c00; font-weight: bold } /* Operator */
.highlight .x { color: #000000 } /* Other */
.highlight .p { color: #000000; font-weight: bold } /* Punctuation */
.highlight .ch { color: #8f5902; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #8f5902; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #8f5902; font-style: italic } /* Comment.Preproc */
.highlight .cpf { color: #8f5902; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #8f5902; font-style: italic } /* Comment.Single */
.highlight .cs { color: #8f5902; font-style: italic } /* Comment.Special */
.highlight .gd { color: #a40000 } /* Generic.Deleted */
.highlight .ge { color: #000000; font-style: italic } /* Generic.Emph */
.highlight .gr { color: #ef2929 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #000000; font-style: italic } /* Generic.Output */
.highlight .gp { color: #8f5902 } /* Generic.Prompt */
.highlight .gs { color: #000000; font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #a40000; font-weight: bold } /* Generic.Traceback */
.highlight .kc { color: #204a87; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #204a87; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #204a87; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #204a87; font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { color: #204a87; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #204a87; font-weight: bold } /* Keyword.Type */
.highlight .ld { color: #000000 } /* Literal.Date */
.highlight .m { color: #0000cf; font-weight: bold } /* Literal.Number */
.highlight .s { color: #4e9a06 } /* Literal.String */
.highlight .na { color: #c4a000 } /* Name.Attribute */
.highlight .nb { color: #204a87 } /* Name.Builtin */
.highlight .nc { color: #000000 } /* Name.Class */
.highlight .no { color: #000000 } /* Name.Constant */
.highlight .nd { color: #5c35cc; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #ce5c00 } /* Name.Entity */
.highlight .ne { color: #cc0000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #000000 } /* Name.Function */
.highlight .nl { color: #f57900 } /* Name.Label */
.highlight .nn { color: #000000 } /* Name.Namespace */
.highlight .nx { color: #000000 } /* Name.Other */
.highlight .py { color: #000000 } /* Name.Property */
.highlight .nt { color: #204a87; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #000000 } /* Name.Variable */
.highlight .ow { color: #204a87; font-weight: bold } /* Operator.Word */
.highlight .w { color: #f8f8f8; text-decoration: underline } /* Text.Whitespace */
.highlight .mb { color: #0000cf; font-weight: bold } /* Literal.Number.Bin */
.highlight .mf { color: #0000cf; font-weight: bold } /* Literal.Number.Float */
.highlight .mh { color: #0000cf; font-weight: bold } /* Literal.Number.Hex */
.highlight .mi { color: #0000cf; font-weight: bold } /* Literal.Number.Integer */
.highlight .mo { color: #0000cf; font-weight: bold } /* Literal.Number.Oct */
.highlight .sa { color: #4e9a06 } /* Literal.String.Affix */
.highlight .sb { color: #4e9a06 } /* Literal.String.Backtick */
.highlight .sc { color: #4e9a06 } /* Literal.String.Char */
.highlight .dl { color: #4e9a06 } /* Literal.String.Delimiter */
.highlight .sd { color: #8f5902; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #4e9a06 } /* Literal.String.Double */
.highlight .se { color: #4e9a06 } /* Literal.String.Escape */
.highlight .sh { color: #4e9a06 } /* Literal.String.Heredoc */
.highlight .si { color: #4e9a06 } /* Literal.String.Interpol */
.highlight .sx { color: #4e9a06 } /* Literal.String.Other */
.highlight .sr { color: #4e9a06 } /* Literal.String.Regex */
.highlight .s1 { color: #4e9a06 } /* Literal.String.Single */
.highlight .ss { color: #4e9a06 } /* Literal.String.Symbol */
.highlight .bp { color: #3465a4 } /* Name.Builtin.Pseudo */
.highlight .fm { color: #000000 } /* Name.Function.Magic */
.highlight .vc { color: #000000 } /* Name.Variable.Class */
.highlight .vg { color: #000000 } /* Name.Variable.Global */
.highlight .vi { color: #000000 } /* Name.Variable.Instance */
.highlight .vm { color: #000000 } /* Name.Variable.Magic */
.highlight .il { color: #0000cf; font-weight: bold } /* Literal.Number.Integer.Long */
    .highlight .mb, .highlight .mf, .highlight .mh, .highlight .mi,
    .highlight .mo { color: #0063cf; }
    </style><main>
<!-- GITHUB FORK ME LOGO -->
<a aria-label="View source on Github" class="github-corner" href="https://github.com/prideout/snowy">
<svg aria-hidden="true" height="80" style="color:#fff; position: absolute; top: 0; border: 0;
right: 0;" viewbox="0 0 250 250" width="80"> <path d="M0,0 L115,115 L130,115 L142,142
L250,250 L250,0 Z"></path> <path class="octo-arm" d="M128.3,109.0 C113.8,99.7 119.0,89.6
119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3
123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9
134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;"></path><path class="octo-body" d="M115.0,115.0 C114.9,115.1 118.7,116.5
119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0
127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4
163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6
187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2
216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4
203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1
C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7
141.6,141.9 141.8,141.8 Z" fill="currentColor"></path></svg></a>
<style>.github-corner:hover svg { fill: #19529d }</style>
<small>v0.0.7 ~ <a href="https://github.com/prideout/snowy/tree/8378e37">8378e37</a></small>
<h1>Snowy <img height="64px" src="snowy2.png" style="vertical-align:text-bottom;margin-left:10px"/></h1>
<p><a href="index.html">User's Guide</a> | <strong>API Reference</strong></p>
<hr/>
<table>
<tr>
<td><a href="#add_border">add_border</a></td>
<td>Extend the size of an image by adding borders.</td>
<tr>
<tr>
<td><a href="#blur">blur</a></td>
<td>Resample an image and produce a new image with the same size.</td>
<tr>
<tr>
<td><a href="#compose">compose</a></td>
<td>Compose a source image with alpha onto a destination image.</td>
<tr>
<tr>
<td><a href="#compose_premultiplied">compose_premultiplied</a></td>
<td>Draw an image with premultiplied alpha over the destination.</td>
<tr>
<tr>
<td><a href="#compute_normals">compute_normals</a></td>
<td>Generate a 3-channel normal map from a height map.</td>
<tr>
<tr>
<td><a href="#compute_skylight">compute_skylight</a></td>
<td>Compute ambient occlusion from a height map.</td>
<tr>
<tr>
<td><a href="#compute_sobel">compute_sobel</a></td>
<td>Apply Sobel operator for edge detection.</td>
<tr>
<tr>
<td><a href="#delinearize">delinearize</a></td>
<td>Transform colors from physically linear to perceptually linear.</td>
<tr>
<tr>
<td><a href="#dereference_coords">dereference_coords</a></td>
<td>For each 2D value in the coord field, make a lookup in the source.</td>
<tr>
<tr>
<td><a href="#dereference_cpcf">dereference_cpcf</a></td>
<td>For each 2D value in the coord field, make a lookup in the source.</td>
<tr>
<tr>
<td><a href="#ensure_alpha">ensure_alpha</a></td>
<td>If the incoming image is 3-channel, adds a 4th channel.</td>
<tr>
<tr>
<td><a href="#export">export</a></td>
<td>Export a numpy array to a PNG, JPEG, or EXR image file.</td>
<tr>
<tr>
<td><a href="#extract_alpha">extract_alpha</a></td>
<td>Extract the alpha plane from an RGBA image.</td>
<tr>
<tr>
<td><a href="#extract_rgb">extract_rgb</a></td>
<td>Extract the RGB planes from an RGBA image.</td>
<tr>
<tr>
<td><a href="#from_planar">from_planar</a></td>
<td>Create a channel-major image into row-major image.</td>
<tr>
<tr>
<td><a href="#generate_cpcf">generate_cpcf</a></td>
<td>Create closest point coordinate field from a boolean field.</td>
<tr>
<tr>
<td><a href="#generate_fbm">generate_fBm</a></td>
<td>Generate 2D fractional brownian motion by adding layers of noise.</td>
<tr>
<tr>
<td><a href="#generate_gdf">generate_gdf</a></td>
<td>Create an generalized squared distance field from a scalar field.</td>
<tr>
<tr>
<td><a href="#generate_noise">generate_noise</a></td>
<td>Generate a single-channel gradient noise image.</td>
<tr>
<tr>
<td><a href="#generate_sdf">generate_sdf</a></td>
<td>Create a signed distance field from a boolean field.</td>
<tr>
<tr>
<td><a href="#generate_udf">generate_udf</a></td>
<td>Create an unsigned distance field from a boolean field.</td>
<tr>
<tr>
<td><a href="#gradient">gradient</a></td>
<td>Compute X derivatives and Y derivatives.</td>
<tr>
<tr>
<td><a href="#hflip">hflip</a></td>
<td>Horizontally mirror the given image.</td>
<tr>
<tr>
<td><a href="#hstack">hstack</a></td>
<td>Horizontally concatenate a list of images with a border.</td>
<tr>
<tr>
<td><a href="#linearize">linearize</a></td>
<td>Transform colors from perceptually linear to physically linear.</td>
<tr>
<tr>
<td><a href="#load">load</a></td>
<td>Create a numpy array from the given PNG, JPEG, or EXR image file.</td>
<tr>
<tr>
<td><a href="#reshape">reshape</a></td>
<td>Add a trailing dimension to single-channel 2D images.</td>
<tr>
<tr>
<td><a href="#resize">resize</a></td>
<td>Create a new numpy image with the desired size.</td>
<tr>
<tr>
<td><a href="#rgb_to_luminance">rgb_to_luminance</a></td>
<td>Read the first three color planes and return a grayscale image.</td>
<tr>
<tr>
<td><a href="#rotate">rotate</a></td>
<td>Rotate image counter-clockwise by a multiple of 90 degrees.</td>
<tr>
<tr>
<td><a href="#show">show</a></td>
<td>Display an image in a platform-specific way.</td>
<tr>
<tr>
<td><a href="#to_planar">to_planar</a></td>
<td>Convert a row-major image into a channel-major image.</td>
<tr>
<tr>
<td><a href="#unitize">unitize</a></td>
<td>Remap the values so that they span the range from 0 to +1.</td>
<tr>
<tr>
<td><a href="#unshape">unshape</a></td>
<td>Remove the trailing dimension from single-channel 3D images.</td>
<tr>
<tr>
<td><a href="#vflip">vflip</a></td>
<td>Vertically mirror the given image.</td>
<tr>
<tr>
<td><a href="#vstack">vstack</a></td>
<td>Vertically concatenate a list of images with a border.</td>
<tr>
</tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></tr></table>
<hr/>
<h3 id="add_border"><a href="#add_border">add_border</a></h3>
<p>
Extend the size of an image by adding borders.  <p> The <code>sides</code> argument defaults to <code>"LTRB"</code>, which enables borders for all four sides: Left, Top, Right, and Bottom. This can be used to select which borders you wish to add. </p>
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_border</span><span class="p">(</span><span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="s1">'ltrb'</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">image</span>
    <span class="n">sides</span> <span class="o">=</span> <span class="n">sides</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="k">if</span> <span class="s1">'L'</span> <span class="ow">in</span> <span class="n">sides</span><span class="p">:</span> <span class="n">result</span> <span class="o">=</span> <span class="n">add_left</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">'T'</span> <span class="ow">in</span> <span class="n">sides</span><span class="p">:</span> <span class="n">result</span> <span class="o">=</span> <span class="n">add_top</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">'R'</span> <span class="ow">in</span> <span class="n">sides</span><span class="p">:</span> <span class="n">result</span> <span class="o">=</span> <span class="n">add_right</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">'B'</span> <span class="ow">in</span> <span class="n">sides</span><span class="p">:</span> <span class="n">result</span> <span class="o">=</span> <span class="n">add_bottom</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
<h3 id="blur"><a href="#blur">blur</a></h3>
<p>
Resample an image and produce a new image with the same size.  For a list of available filters, see <a href="#resize">resize</a>.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">blur</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="n">GAUSSIAN</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">wrapx</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">wrapy</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">resize</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="nb">filter</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">wrapx</span><span class="p">,</span> <span class="n">wrapy</span><span class="p">)</span>
</pre></div>
<h3 id="compose"><a href="#compose">compose</a></h3>
<p>
Compose a source image with alpha onto a destination image.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">compose</span><span class="p">(</span><span class="n">dst</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ensure_alpha</span><span class="p">(</span><span class="n">src</span><span class="p">),</span> <span class="n">ensure_alpha</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">extract_alpha</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">alpha</span>
    <span class="k">if</span> <span class="n">dst</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">extract_rgb</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
<h3 id="compose_premultiplied"><a href="#compose_premultiplied">compose_premultiplied</a></h3>
<p>
Draw an image with premultiplied alpha over the destination.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">compose_premultiplied</span><span class="p">(</span><span class="n">dst</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ensure_alpha</span><span class="p">(</span><span class="n">src</span><span class="p">),</span> <span class="n">ensure_alpha</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">extract_alpha</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span>
    <span class="k">if</span> <span class="n">dst</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">extract_rgb</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
<h3 id="compute_normals"><a href="#compute_normals">compute_normals</a></h3>
<p>
Generate a 3-channel normal map from a height map.  The normal components are in the range [-1,+1] and the size of the normal map is (width-1, height-1) due to forward differencing.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">compute_normals</span><span class="p">(</span><span class="n">elevation</span><span class="p">):</span>
    <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">nchan</span> <span class="o">=</span> <span class="n">elevation</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">assert</span> <span class="n">nchan</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="n">normals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
    <span class="n">_compute_normals</span><span class="p">(</span><span class="n">elevation</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">normals</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">normals</span>
</pre></div>
<h3 id="compute_skylight"><a href="#compute_skylight">compute_skylight</a></h3>
<p>
Compute ambient occlusion from a height map.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">compute_skylight</span><span class="p">(</span><span class="n">elevation</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">nchan</span> <span class="o">=</span> <span class="n">elevation</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">assert</span> <span class="n">nchan</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">])</span>
    <span class="n">_compute_skylight</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">elevation</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">verbose</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">io</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">result</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
<h3 id="compute_sobel"><a href="#compute_sobel">compute_sobel</a></h3>
<p>
Apply Sobel operator for edge detection.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">compute_sobel</span><span class="p">(</span><span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="s2">"Apply Sobel operator for edge detection."</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">'Shape is not rows x cols x channels'</span>
    <span class="k">assert</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'Image must be grayscale'</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">_compute_sobel</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>
 <span class="n">compute_sobel</span><span class="p">(</span><span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="s2">"Apply Sobel operator for edge detection."</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">'Shape is not rows x cols x channels'</span>
    <span class="k">assert</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'Image must be grayscale'</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">_compute_sobel</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
<h3 id="delinearize"><a href="#delinearize">delinearize</a></h3>
<p>
Transform colors from physically linear to perceptually linear.  This is automatically performed when using <a href="#export">export</a> to a PNG or JPEG. See also <a href="#linearize">linearize</a>.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">delinearize</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">source_space</span><span class="o">=</span><span class="n">SRGB</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">source_space</span> <span class="o">==</span> <span class="n">SRGB</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">linear_to_sRGB</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">linear_to_gamma</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
<h3 id="dereference_coords"><a href="#dereference_coords">dereference_coords</a></h3>
<p>
For each 2D value in the coord field, make a lookup in the source. This is useful for creating generalized voronoi diagrams.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dereference_coords</span><span class="p">(</span><span class="n">source</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">coords</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">'Shape is not rows x cols x channels'</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">'Shape is not rows x cols x channels'</span>
    <span class="k">assert</span> <span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'Coordinate must be 2-tuples'</span>
    <span class="n">voronoi</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">height</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">coords</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">coords</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">_deref_coords</span><span class="p">(</span><span class="n">voronoi</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">voronoi</span>
</pre></div>
<h3 id="dereference_cpcf"><a href="#dereference_cpcf">dereference_cpcf</a></h3>
<p>
For each 2D value in the coord field, make a lookup in the source. This is useful for creating generalized voronoi diagrams.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dereference_coords</span><span class="p">(</span><span class="n">source</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">coords</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">'Shape is not rows x cols x channels'</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">'Shape is not rows x cols x channels'</span>
    <span class="k">assert</span> <span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'Coordinate must be 2-tuples'</span>
    <span class="n">voronoi</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">height</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">coords</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">coords</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">_deref_coords</span><span class="p">(</span><span class="n">voronoi</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">voronoi</span>
</pre></div>
<h3 id="ensure_alpha"><a href="#ensure_alpha">ensure_alpha</a></h3>
<p>
If the incoming image is 3-channel, adds a 4th channel.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">ensure_alpha</span><span class="p">(</span><span class="n">src</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="k">if</span> <span class="n">src</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">src</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">to_planar</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">from_planar</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">alpha</span><span class="p">]))</span>
</pre></div>
<h3 id="export"><a href="#export">export</a></h3>
<p>
Export a numpy array to a PNG, JPEG, or EXR image file.  This function automatically multiplies PNG / JPEG images by 255.  See also <a href="#unshape">unshape</a> and <a href="#delinearize">delinearize</a> (which this calls).
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">export</span><span class="p">(</span><span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">delinearize</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">'.png'</span><span class="p">)</span> <span class="ow">or</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">'.jpeg'</span><span class="p">)</span> <span class="ow">or</span> \
            <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">'.jpg'</span><span class="p">)</span> <span class="ow">or</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">'.exr'</span><span class="p">)</span>
    <span class="n">_export</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">delinearize</span><span class="p">)</span>
</pre></div>
<h3 id="extract_alpha"><a href="#extract_alpha">extract_alpha</a></h3>
<p>
Extract the alpha plane from an RGBA image.  Note that this returns a copy, not a view. To manipulate the pixels in a <i>view</i> of the alpha plane, simply make a numpy slice, as in: <code>alpha_view = myimage[:,:,3]</code>.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">extract_alpha</span><span class="p">(</span><span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dsplit</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">4</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>
<h3 id="extract_rgb"><a href="#extract_rgb">extract_rgb</a></h3>
<p>
Extract the RGB planes from an RGBA image.  Note that this returns a copy. If you wish to obtain a view that allows mutating pixels, simply use slicing instead. For example, to invert the colors of an image while leaving alpha intact, you can do: <code>myimage[:,:,:3] = 1.0 - myimage[:,:,:3]</code>.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">extract_rgb</span><span class="p">(</span><span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span>
    <span class="n">planes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dsplit</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span><span class="n">planes</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>
</pre></div>
<h3 id="from_planar"><a href="#from_planar">from_planar</a></h3>
<p>
Create a channel-major image into row-major image.  This creates a copy, not a view.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">from_planar</span><span class="p">(</span><span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
<h3 id="generate_cpcf"><a href="#generate_cpcf">generate_cpcf</a></h3>
<p>
Create closest point coordinate field from a boolean field.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">generate_cpcf</span><span class="p">(</span><span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">image</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">'bool'</span><span class="p">,</span> <span class="s1">'Pixel values must be boolean'</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">'Shape is not rows x cols x channels'</span>
    <span class="k">assert</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'Image must be grayscale'</span>
    <span class="k">return</span> <span class="n">_generate_cpcf</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
<h3 id="generate_fbm"><a href="#generate_fbm">generate_fBm</a></h3>
<p>
Generate 2D fractional brownian motion by adding layers of noise.  See also <a href="#generate_noise">generate_noise</a>.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">generate_fBm</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">layers</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span> <span class="n">lacunarity</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">persistence</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">wrapx</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">wrapy</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="n">generate_noise</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">amplitude</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">layers</span><span class="p">):</span>
        <span class="n">lseed</span> <span class="o">=</span> <span class="n">seed</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="n">amplitude</span> <span class="o">*</span> <span class="n">noise</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">lseed</span><span class="p">,</span> <span class="n">wrapx</span><span class="p">,</span> <span class="n">wrapy</span><span class="p">)</span>
        <span class="n">freq</span> <span class="o">*=</span> <span class="n">lacunarity</span>
        <span class="n">amplitude</span> <span class="o">/=</span> <span class="n">persistence</span>
    <span class="k">return</span> <span class="n">n</span>
</pre></div>
<h3 id="generate_gdf"><a href="#generate_gdf">generate_gdf</a></h3>
<p>
Create an generalized squared distance field from a scalar field.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">generate_gdf</span><span class="p">(</span><span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">wrapx</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">wrapy</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="s2">"Create an generalized squared distance field from a scalar field."</span>
    <span class="k">assert</span> <span class="n">image</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">'float64'</span><span class="p">,</span> <span class="s1">'Pixel values must be real'</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">'Shape is not rows x cols x channels'</span>
    <span class="k">assert</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'Image must be grayscale'</span>
 <span class="n">generate_gdf</span><span class="p">(</span><span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">wrapx</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">wrapy</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="s2">"Create an generalized squared distance field from a scalar field."</span>
    <span class="k">assert</span> <span class="n">image</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">'float64'</span><span class="p">,</span> <span class="s1">'Pixel values must be real'</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">'Shape is not rows x cols x channels'</span>
    <span class="k">assert</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'Image must be grayscale'</span>
    <span class="k">return</span> <span class="n">_generate_gdt</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">wrapx</span><span class="p">,</span> <span class="n">wrapy</span><span class="p">)</span>
</pre></div>
<h3 id="generate_noise"><a href="#generate_noise">generate_noise</a></h3>
<p>
Generate a single-channel gradient noise image.  A frequency of 1.0 creates a single surflet across the width of the image, while a frequency of 4.0 creates a 4x4 grid such that the (2,2) surflet is centered. Noise values live within the [-1,+1] range.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">generate_noise</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">wrapx</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                   <span class="n">wrapy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]):</span>
    <span class="k">return</span> <span class="n">_noise</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span> <span class="n">wrapx</span><span class="p">,</span> <span class="n">wrapy</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
</pre></div>
<h3 id="generate_sdf"><a href="#generate_sdf">generate_sdf</a></h3>
<p>
Create a signed distance field from a boolean field.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">generate_sdf</span><span class="p">(</span><span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">wrapx</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">wrapy</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">generate_udf</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">wrapx</span><span class="p">,</span> <span class="n">wrapy</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">generate_udf</span><span class="p">(</span><span class="n">image</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">wrapx</span><span class="p">,</span> <span class="n">wrapy</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span>
</pre></div>
<h3 id="generate_udf"><a href="#generate_udf">generate_udf</a></h3>
<p>
Create an unsigned distance field from a boolean field.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">generate_udf</span><span class="p">(</span><span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">wrapx</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">wrapy</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">image</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">'bool'</span><span class="p">,</span> <span class="s1">'Pixel values must be boolean'</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">'Shape is not rows x cols x channels'</span>
    <span class="k">assert</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'Image must be grayscale'</span>
    <span class="k">return</span> <span class="n">_generate_edt</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">wrapx</span><span class="p">,</span> <span class="n">wrapy</span><span class="p">)</span>
</pre></div>
<h3 id="gradient"><a href="#gradient">gradient</a></h3>
<p>
Compute X derivatives and Y derivatives.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
    <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">unshape</span><span class="p">(</span><span class="n">img</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">reshape</span><span class="p">(</span><span class="n">nx</span><span class="p">),</span> <span class="n">reshape</span><span class="p">(</span><span class="n">ny</span><span class="p">)</span>
</pre></div>
<h3 id="hflip"><a href="#hflip">hflip</a></h3>
<p>
Horizontally mirror the given image.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">hflip</span><span class="p">(</span><span class="n">source</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">'Shape is not rows x cols x channels'</span>
    <span class="k">assert</span> <span class="n">source</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="s1">'Images must be doubles.'</span>
    <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">c</span><span class="p">])</span>
    <span class="n">jit_hflip</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
<h3 id="hstack"><a href="#hstack">hstack</a></h3>
<p>
Horizontally concatenate a list of images with a border.  This is similar to numpy's <code>hstack</code> except that it adds a border around each image. The borders can be controlled with the optional <code>border_width</code> and <code>border_value</code> arguments. See also <a href="#vstack"> vstack</a>.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">hstack</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">border_width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">border_value</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">border_width</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
    <span class="n">T</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">border_width</span><span class="p">,</span> <span class="n">border_value</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">images</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">add_border</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="s1">'LTB'</span><span class="p">))</span>
    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">add_border</span><span class="p">(</span><span class="n">images</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">T</span><span class="p">,</span> <span class="n">V</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
<h3 id="linearize"><a href="#linearize">linearize</a></h3>
<p>
Transform colors from perceptually linear to physically linear.  This is automatically performed when using <a href="#load">load</a> on a PNG or JPEG. See also <a href="#delinearize">delinearize</a>.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">linearize</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">target_space</span><span class="o">=</span><span class="n">SRGB</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">target_space</span> <span class="o">==</span> <span class="n">SRGB</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sRGB_to_linear</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">gamma_to_linear</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
<h3 id="load"><a href="#load">load</a></h3>
<p>
Create a numpy array from the given PNG, JPEG, or EXR image file.  Regardless of the pixel format on disk, PNG / JPEG images are always divided by 255, and PNG images are extended to 4 color channels.  See also <a href="#reshape">reshape</a> and <a href="#linearize">linearize</a>  (which this calls).
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">linearize</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>

    <span class="n">ext</span> <span class="o">=</span> <span class="n">filename</span><span class="p">[</span><span class="n">filename</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s1">'.'</span><span class="p">):]</span>
    <span class="k">assert</span> <span class="n">ext</span> <span class="o">==</span> <span class="s1">'.png'</span> <span class="ow">or</span> <span class="n">ext</span> <span class="o">==</span> <span class="s1">'.jpeg'</span> <span class="ow">or</span> <span class="n">ext</span> <span class="o">==</span> <span class="s1">'.jpg'</span> <span class="ow">or</span> <span class="n">ext</span> <span class="o">==</span> <span class="s1">'.exr'</span>
    <span class="k">return</span> <span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">_load</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">ext</span><span class="p">,</span> <span class="ow">not</span> <span class="n">linearize</span><span class="p">)))</span>
</pre></div>
<h3 id="reshape"><a href="#reshape">reshape</a></h3>
<p>
Add a trailing dimension to single-channel 2D images.  See also <a href="#unshape">unshape</a>.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">reshape</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
    <span class="k">return</span> <span class="n">image</span>
</pre></div>
<h3 id="resize"><a href="#resize">resize</a></h3>
<p>
Create a new numpy image with the desired size.  Either width or height can be null, in which case its value is inferred from the aspect ratio of the source image.  Filter can be HERMITE, TRIANGLE, GAUSSIAN, NEAREST, LANCZOS, or MITCHELL.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">resize</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
           <span class="n">wrapx</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">wrapy</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">'Shape is not rows x cols x channels'</span>
    <span class="k">assert</span> <span class="n">width</span> <span class="o">!=</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">height</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">,</span>  <span class="s1">'Missing target size'</span>
    <span class="n">aspect</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">source</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">width</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span> <span class="n">width</span> <span class="o">=</span> <span class="n">height</span> <span class="o">*</span> <span class="n">aspect</span>
    <span class="k">if</span> <span class="n">height</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span> <span class="n">height</span> <span class="o">=</span> <span class="n">width</span> <span class="o">/</span> <span class="n">aspect</span>
    <span class="n">magnifying</span> <span class="o">=</span> <span class="n">width</span> <span class="o">&gt;</span> <span class="n">source</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">filter</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span> <span class="nb">filter</span> <span class="o">=</span> <span class="n">MITCHELL</span> <span class="k">if</span> <span class="n">magnifying</span> <span class="k">else</span> <span class="n">LANCZOS</span>
    <span class="k">return</span> <span class="n">resample</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="nb">filter</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">wrapx</span><span class="p">,</span> <span class="n">wrapy</span><span class="p">)</span>
</pre></div>
<h3 id="rgb_to_luminance"><a href="#rgb_to_luminance">rgb_to_luminance</a></h3>
<p>
Read the first three color planes and return a grayscale image.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">rgb_to_luminance</span><span class="p">(</span><span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="s2">"Read the first three color planes and return a grayscale image."</span>
    <span class="k">assert</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span>
    <span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dsplit</span><span class="p">(</span><span class="n">image</span><span class="p">[:,:,:</span><span class="mi">3</span><span class="p">],</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
 <span class="n">rgb_to_luminance</span><span class="p">(</span><span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="s2">"Read the first three color planes and return a grayscale image."</span>
    <span class="k">assert</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span>
    <span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dsplit</span><span class="p">(</span><span class="n">image</span><span class="p">[:,:,:</span><span class="mi">3</span><span class="p">],</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">io</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mf">0.2125</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="mf">0.7154</span> <span class="o">*</span> <span class="n">g</span> <span class="o">+</span> <span class="mf">0.0721</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
<h3 id="rotate"><a href="#rotate">rotate</a></h3>
<p>
Rotate image counter-clockwise by a multiple of 90 degrees.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="n">source</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">degrees</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">'Shape is not rows x cols x channels'</span>
    <span class="k">assert</span> <span class="n">source</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="s1">'Images must be doubles.'</span>
    <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">degrees</span> <span class="o">%=</span> <span class="mi">360</span>
    <span class="k">if</span> <span class="n">degrees</span> <span class="o">==</span> <span class="mi">90</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">])</span>
        <span class="n">rotate90</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">degrees</span> <span class="o">==</span> <span class="mi">180</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">c</span><span class="p">])</span>
        <span class="n">rotate180</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">degrees</span> <span class="o">==</span> <span class="mi">270</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">])</span>
        <span class="n">rotate270</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s1">'Angle must be a multiple of 90.'</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
<h3 id="show"><a href="#show">show</a></h3>
<p>
Display an image in a platform-specific way.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">delinearize</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">show_array</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">delinearize</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">show_filename</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Unsupported type'</span><span class="p">)</span>
</pre></div>
<h3 id="to_planar"><a href="#to_planar">to_planar</a></h3>
<p>
Convert a row-major image into a channel-major image.  This creates a copy, not a view.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">to_planar</span><span class="p">(</span><span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dsplit</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
<h3 id="unitize"><a href="#unitize">unitize</a></h3>
<p>
Remap the values so that they span the range from 0 to +1.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">unitize</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">img</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">img</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">img</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">img</span><span class="p">))</span>
</pre></div>
<h3 id="unshape"><a href="#unshape">unshape</a></h3>
<p>
Remove the trailing dimension from single-channel 3D images.  See also <a href="#reshape">reshape</a>.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">unshape</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">image</span>
</pre></div>
<h3 id="vflip"><a href="#vflip">vflip</a></h3>
<p>
Vertically mirror the given image.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">vflip</span><span class="p">(</span><span class="n">source</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">'Shape is not rows x cols x channels'</span>
    <span class="k">assert</span> <span class="n">source</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="s1">'Images must be doubles.'</span>
    <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">c</span><span class="p">])</span>
    <span class="n">jit_vflip</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
<h3 id="vstack"><a href="#vstack">vstack</a></h3>
<p>
Vertically concatenate a list of images with a border.  This is similar to numpy's <code>vstack</code> except that it adds a border around each image. The borders can be controlled with the optional <code>border_width</code> and <code>border_value</code> arguments. See also <a href="#hstack"> hstack</a>.
</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">vstack</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">border_width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">border_value</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">border_width</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
    <span class="n">T</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">border_width</span><span class="p">,</span> <span class="n">border_value</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">images</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">add_border</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="s1">'LTR'</span><span class="p">))</span>
    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">add_border</span><span class="p">(</span><span class="n">images</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">T</span><span class="p">,</span> <span class="n">V</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</main>
</head>